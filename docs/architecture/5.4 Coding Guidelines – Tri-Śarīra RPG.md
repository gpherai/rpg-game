# 5.4 Coding Guidelines – Tri-Śarīra RPG

**Versie:** 0.1  
**Auteur:** Gerald (met Architect- & Game Designer-ondersteuning)  
**Status:** Richtlijn. Niet keihard dogmatisch, wel de default manier van werken voor deze codebase.

Doel:

- Zorgen dat **alle code dezelfde taal spreekt** – of jij het schrijft of een AI (Codex/Claude/etc.).  
- Complexiteit beheersbaar houden voor een **grote, lange RPG**.  
- Fouten en regressies beperken door een minimale standaard in stijl, structuur en testen.

---

## 1. Algemene principes

1. **Leesbaarheid boven slimheid**  
   - Schrijf code die je over 6 maanden nog snapt.  
   - Vermijd "clevere" één-regel-trucs als een duidelijke variant maar 2–3 regels langer is.

2. **Data-driven waar mogelijk**  
   - Content (actors, enemies, items, quests, dialogue, zones, events) hoort in JSON/Tiled, niet hardcoded.  
   - Code definieert *regels*, data definieert *inhoud*.

3. **Scheiding van verantwoordelijkheden**  
   - Systems doen de logica, Scenes doen presentatie & input-flow.  
   - `systems/` kent geen Pygame API’s; `presentation/` weet niets van JSON-bestanden.

4. **Korte functies, duidelijke namen**  
   - Richtlijn: functies 10–30 regels, uitzonderingen voor simpele data-klassen.  
   - Naam geeft intentie: `apply_damage_to_target` is beter dan `do_stuff`.

5. **Expliciet > impliciet**  
   - Geef argumenten bij voorkeur **named** door (zeker bij booleans).  
   - Maak data-structuren expliciet (dataclasses/dicts met vaste keys) i.p.v. magische tuples.

---

## 2. Stijl & tooling

### 2.1 Formatter & linter

- **Formatter:** `black`  
  - Gebruik standaardinstellingen.  
  - Geen handmatig micro-formatten; laat `black` beslissen.

- **Linter:** `ruff`  
  - Minimalistische config: PEP8 + een basisset extra checks (unused imports, dode code, etc.).

### 2.2 Type hints

- Gebruik **type hints** in alle publieke functies/methoden in `systems/`, `data_access/` en `core/`.  
- In `presentation/` mag je pragmatischer zijn, maar liever wél typen voor main paths.

- `mypy` (of ruff/type-check) draait minimaal op:  
  - `core/`,  
  - `systems/`,  
  - `data_access/`.

### 2.3 Naamconventies

- Python standaard (PEP8):
  - modules: `lower_snake_case.py`  
  - functies/methoden: `lower_snake_case`  
  - klassen: `CamelCase`  
  - constants: `UPPER_SNAKE_CASE`

- ID’s voor data (zie 4.1/4.2):  
  - actors: `mc_adhira`, `comp_rajani`  
  - enemies: `en_forest_sprout`  
  - quests: `q_r1_001_shrine_intro`  
  - zones: `z_r1_chandrapur_town`  
  - items: `it_herb_minor`, `wp_training_staff`  
  - skills: `sk_body_strike`  
  - events: `ev_start_shrine_battle`

Deze ID’s zijn **stabiel** – code mag er niet zomaar andere vormen van maken.

---

## 3. Structuur van modules & klassen

### 3.1 Eén systeem per module

- `systems.world` bevat `WorldSystem` + gerelateerde kleine types (`WorldMap`, `EntityRef`, etc.).  
- `systems.combat` bevat `CombatSystem`, `BattleContext`, damage-calculators.  
- Liever niet meerdere volledig onafhankelijke systemen in hetzelfde bestand.

### 3.2 Domeinlogica in systems, niet in Scenes

- **Wel in system:**  
  - Hoe damage precies wordt berekend.  
  - Welke quest-stage de volgende is na een event.  
  - Hoe XP zich vertaalt naar level-up.

- **Wel in Scene/presentation:**  
  - Hoe een HP-balk eruit ziet en waar hij op het scherm staat.  
  - Welke toetsen je indrukt om een skill te selecteren.  
  - Overgangen tussen scenes (van overworld naar battle).

### 3.3 Data-access scheiden

- `DataRepository` verzorgt alle **lookup** van content uit JSON (`get_actor`, `get_quest`, `get_dialogue`, etc.).  
- Systems vragen nooit zelf via `open()` een JSON-bestand; ze gebruiken de repository.

---

## 4. Fouten, logging & asserts

### 4.1 Logging

- Gebruik Python `logging` i.p.v. `print`.  
- Richtlijnen:
  - `logger.debug` voor detaildebug (battle-calculaties, pathfinding traces).  
  - `logger.info` voor high-level events (quest completed, zone change, save/load).  
  - `logger.warning` voor verdachte toestand waar spel nog wel mee door kan.  
  - `logger.error` voor echte fouten (ontbrekende essentiële data, save-fail).  

- Geen logspam binnen de main-loop op `INFO` voor elke frame; focus op relevante events.

### 4.2 Error-handling

- **Data-load**: faalt hard als core-data ontbreekt of niet valideert tegen schema.  
- **Runtime**:  
  - Bij missende referenties (item_id, quest_id) → log `error` met zoveel mogelijk info (`quest_id`, `stage`, etc.) en gebruik een veilige fallback (bijv. negeer reward).  
  - Crashes in battle/overworld zijn acceptabel in dev; in release bij voorkeur opgevangen met nette foutmelding/log waar mogelijk.

### 4.3 Asserts

- Gebruik `assert` voor **invariants die nooit mogen voorkomen** in valide code/data.  
- Voorbeelden:  
  - `assert attacker.hp > 0` bij start van een attack.  
  - `assert zone_id in self.zones` in WorldSystem init.  
- Asserts zijn vooral voor dev-build; geen game-logica op baseren (zoals user input-fouten).

---

## 5. Documentatie & comments

### 5.1 Docstrings

- Publieke klassen en belangrijke methods krijgen een **korte docstring**:

  - Wat doet deze klasse/methode?  
  - Welke belangrijke parameters/return-values zijn er?  

- Geen romans; 1–3 regels is vaak genoeg.

### 5.2 Comments

- Gebruik comments voor **waarom**, niet voor **wat**.  
  - Slecht: `# add 10 to HP` als de code `hp += 10` al zegt wat er gebeurt.  
  - Goed: `# small heal to reward perfect-guard timing`.

- Als je een workaround/hack gebruikt, label het: `# TODO:`, `# FIXME:`, kort met context.

### 5.3 README’s per map/system (optioneel)

- Bij complexe systemen (bv. combat, quests) kan een korte `README.md` in de map handig zijn:  
  - rol van het systeem,  
  - hoe data-flow loopt,  
  - typische use-cases.

---

## 6. Testen

### 6.1 Unit tests

- Prioriteit voor `systems/` en `data_access/`:
  - Combat-calculatie (damage, status, resistances).  
  - Quest-state transitions.  
  - Save/load roundtrip (maak SaveData → schrijf → lees → vergelijk kernvelden).

- Houd tests klein en duidelijk: één concept per test.

### 6.2 Data-tests

- `tools/validate_data.py` is leidend voor JSON-validatie.  
- `pytest`-tests mogen deze tool aanroepen om te checken of **alle data** valide is.

### 6.3 Geen TDD-religie

- We forceren geen 100% coverage.  
- Wel:  
  - nieuwe systemen → minimaal een paar kern-tests,  
  - bugfixes → bij voorkeur een test die het regressiegevaar minimaliseert.

---

## 7. Samenwerking met AI (Codex/Claude/etc.)

### 7.1 Waar AI-code mag landen

- Nieuwe features alleen in mappen die al zijn gedefinieerd in 5.3.  
- Geen nieuwe top-level mappen aanmaken zonder dat dit eerst in de architectuur/folder-structuur wordt aangepast.

### 7.2 Opdrachten aan AI

- Geef altijd aan:  
  - in welke module (`systems.combat`, `presentation.overworld`, …) de code moet komen;  
  - welke bestaande types/ID’s gebruikt moeten worden (`mc_adhira`, `q_r1_001_shrine_intro`, etc.);  
  - dat `black`/PEP8 gevolgd moet worden en type hints gewenst zijn.

### 7.3 Review

- Controleer AI-code op:
  - Houdt het de scheiding po/systems vs presentation in stand?  
  - Respecteert het bestaande ID-conventies en data-structuren?  
  - Zijn er onnodige dependencies toegevoegd?

- Zo nodig: refactor direct of noteer een `TODO` met korte uitleg.

---

## 8. Specifiek voor Pygame & performance

### 8.1 Pygame gebruik

- Eén centrale **main-loop** (in `Game.run`).  
- Geen nested `pygame.event.get()` loops in Scenes; input-afhandeling gecentraliseerd of volgens afgesproken patroon.  
- Resources (sprites/audio) via `ResourceManager` geladen, niet telkens via `pygame.image.load` in Scenes.

### 8.2 Performance-richtlijnen

- Vermijd zware allocaties in per-frame code (geen grote dicts/lists maken in elke `update`/`render`).  
- Cache veelgebruikte lookups (bijv. tileset-slices, animations).  
- Als iets **per seconde** voldoende is, doe het niet **per frame**.

### 8.3 Pixel-art & resolutie

- Houd interne resolutie en scale-factor centraal in Config.  
- Geen magic numbers voor screen size door de code heen strooien.

---

## 9. Tri-Śarīra-specifiek

### 9.1 Domeinbegrippen

- Gebruik consistente namen:  
  - `body_score`, `mind_score`, `spirit_score`  
  - `TriDomain`, `tri_profile`, `tri_focus_primary`  
  - Niet elke keer andere varianten (`bms_scores`, `phys_score` etc.).

### 9.2 Symbolische logica

- Tri-śarīra / dharma-logica zit vooral in **systems.progression**, **systems.quests** en **data** (tags, flags).  
- Houd dit overzichtelijk en documenteer beslissingen kort in comments of README.

---

## 10. Wat doen we bewust niet

- Geen over-engineerde patterns (geen DI-framework, geen hyper-complexe ECS) zolang de schaal dat niet echt vraagt.  
- Geen directe file-I/O in scenes of random delen van de code – alles via centrale services (config, data, save).  
- Geen globale variabelen voor belangrijke state; gebruik systemen en duidelijk doorgegeven referenties.

---

Versie 0.1 is de **basisafspraak**. Als de game groeit en je merkt dat iets structureel schuurt, wordt de guideline aangepast – niet ad-hoc genegeerd in losse modules.

