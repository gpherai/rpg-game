# 5.2 Code Architectuur-overzicht (light) – Tri-Śarīra RPG

**Versie:** 0.1  
**Auteur:** Gerald (met Architect- & Game Designer-ondersteuning)  
**Status:** Light architectuur-overzicht. Geen volledige C4-set, maar een heldere mentale map voor hoe de code in elkaar grijpt.

Doel:

- Een **overzicht in woorden** van de belangrijkste modules, lagen en afhankelijkheden.  
- Zorgen dat Codex / Claude Code begrijpt *waar* nieuwe code moet landen.  
- Aansluiten op 5.1 Tech Overview, 5.3 Folder- & Module-structuur en de 3.x/4.x systems- & dataspecs.

---

## 1. Hoofdlagen

We werken met drie hoofdlagen:

1. **App & Engine-laag**  
   - Startpunt, main-loop, Pygame-setup, SceneManager.  
   - Weinig game-logica; vooral orchestratie.

2. **Systems-laag (game logica)**  
   - World, Combat, NPC & Party, Quests & Dialogue, Time, Items/Economy, Progression & Save.  
   - Zoveel mogelijk **engine-onafhankelijk** (zuivere Python, geen Pygame in de kernlogica).

3. **Data & Content-laag**  
   - JSON-data (`data/*.json`), schema’s (`schema/*.schema.json`).  
   - Tiled-maps (`maps/*.tmx`), tilesets, assets.  
   - Worden via een `DataRepository` en maploader naar systems gevoerd.

Bovenop deze lagen zit de **UI/Presentation** (overworld rendering, menu’s, dialogueboxen, battle UI) die Pygame gebruikt om de systems-states te tonen.

---

## 2. Globale module-indeling (conceptueel)

Niet de exacte folderstructuur (die komt in 5.3), maar de **logische modules**:

- `app` – entrypoint & bootstrap  
- `core` – basisbouwstenen voor scenes, events, resources, config  
- `systems` – losse subsystemen (wereld, combat, quests, etc.)  
- `data` – runtime datalaag (loaders, repositories, schema-hooks)  
- `presentation` / `ui` – rendering & UI-componenten  
- `tools` – losse scripts (data-validatie, schema-checks, debug)

Afhankelijkheden:

- `app` → gebruikt `core`, `systems`, `data`, `presentation`.  
- `core` → is laag; moet geen concrete gamecontent kennen.  
- `systems` → mag `core` gebruiken (bijv. eventbus, base types), maar niet direct Pygame.  
- `presentation` → praat met `systems` om state op te vragen/aan te sturen.  
- `data` → wordt door `systems` gebruikt om content (actors/items/quests) te laden.

---

## 3. App & Core

### 3.1 `app.game` / `main`-entry

Belangrijkste verantwoordelijkheden:

- Pygame initialiseren (window, clock, surfaces).  
- `Config` laden (paden, resolutie, dev-settings).  
- `ResourceManager` initialiseren (sprites, audio).  
- `DataRepository` initialiseren (JSON-data, schema).  
- Kern-systems maken (WorldSystem, CombatSystem, QuestSystem, TimeSystem, etc.).  
- `SceneManager` maken en initiale scene zetten (`MainMenuScene` of direct `OverworldScene` in dev).

De **main-loop** (in `Game.run()`):

1. Input ophalen  
2. Huidige Scene updaten (met dt)  
3. Huidige Scene renderen  
4. Swap buffers / display flip

### 3.2 `core.scene`

- Abstracte `Scene`-baseclass met hooks:  
  - `handle_input(events)`  
  - `update(dt)`  
  - `render(surface)`  
- `SceneManager` met:  
  - `push_scene(scene)`, `pop_scene()`, `switch_scene(scene)`  
  - stack-gebaseerde benadering mogelijk (overlays).

Concrete scenes:

- `MainMenuScene`  
- `OverworldScene`  
- `BattleScene`  
- `DialogueScene` (optioneel apart)  
- `PauseMenuScene` (later)

### 3.3 `core.resources`

- `ResourceManager` voor sprites, tilesets, audio.  
- Zorgt dat assets maar één keer geladen worden en via ID beschikbaar zijn.

### 3.4 `core.config` & `core.events`

- `Config`-klasse die TOML-bestanden samenvoegt (default + dev).  
- Eenvoudige **eventbus** of signaalmechanisme (optioneel) om losgekoppelde systemen te laten praten (bijv. "quest completed" → andere systemen kunnen luisteren).

---

## 4. Systems-laag (overzicht)

### 4.1 `systems.world`

Verantwoordelijk voor:

- Laden en representeren van de **huidige zone** (Tiled-map → interne `WorldMap`).  
- Tile-collision, walkable tiles, portals, interactables, chests.  
- Positionering van **entities** (player, NPC’s, enemies op overworld).  
- Aanroepen van encounters/logica bij triggers (bv. portal betreden, EventTrigger overlappen).

Koppelt aan:

- `DataRepository` (zones, events, encounters).  
- `TiledLoader` (maps laden).  
- `TimeSystem` (dag/nacht, seizoensinvloeden op encounters).

### 4.2 `systems.combat`

Verantwoordelijk voor:

- Representatie van een **battle** (parties, turn order, acties).  
- Damage-calculatie, status effects, buffs/debuffs.  
- Verwerking van skill-effecten (`effect_ids` uit skills-data).  
- Output: battle-resultaat (XP, loot, flags zoals "boss verslagen").

Koppelt aan:

- `PartySystem` (welke actors doen mee).  
- `ItemsSystem`/Inventory (consumables in battle).  
- `QuestSystem`/Events (quest-progress na gevecht, b.v. defeat_guardian).

### 4.3 `systems.party`

Verantwoordelijk voor:

- Actieve party (volgorde, max party size).  
- Companions toevoegen/verwijderen, fasen van companions (seed/companion/settled).  
- Actor-state in memory: level, XP, stats, skills, gear (in sync met SaveData).

Koppelt aan:

- `DataRepository` (actors-data).  
- `SaveSystem` (store/restore actors-state).  
- `systems.progression` (level-ups, Tri-ontwikkeling).

### 4.4 `systems.quests`

Verantwoordelijk voor:

- Quest-log en quest-state per `quest_id`.  
- Evalueren van objectives (talk to NPC, reach zone, defeat enemy group, collect item…).  
- Hook-punten aanroepen bij events (bv. dialogue-keuze, map-enter, battle-result).

Koppelt aan:

- `systems.flags` / `systems.state` (globale flags, choice-history).  
- `DataRepository` (`quests.json`).  
- `systems.dialogue` (quest-start/advance vanuit dialogen).

### 4.5 `systems.dialogue`

Verantwoordelijk voor:

- Interpreteren van dialogue-graphs (`dialogue.json`).  
- Evalueren van conditions (flags, quest-state, tijd, companions…).  
- Teruggeven van volgende nodes, choices, text-keys.  
- Uitvoeren van effectrefs (set flag, quest-start, give item…).

Veel logica is engine-onafhankelijk; UI (dialogue-box, keuzes) zit in `presentation.ui.dialogue`.

### 4.6 `systems.time`

Verantwoordelijk voor:

- Bijhouden van **dag-index, tijd van de dag, seizoen, jaar**.  
- Triggers aanroepen op dag-/tijd-veranderingen (NPC-schedules, festival-events).  
- Mapping van tijd naar visual profiles (dag/nacht filter).

Koppelt aan:

- `npc_schedules` (waar NPC’s staan per tijdslot).  
- Encounter-tables (anders overdag vs ’s nachts).  
- Events (tijdgebonden festivals).

### 4.7 `systems.items` & `systems.economy`

Verantwoordelijk voor:

- Inventory (items, key items, quest items).  
- Toepassen van itemeffecten (healen, buffen, status herstellen).  
- Shops (beschikbare items, prijzen, stock).  
- Currencybeheer.

Koppelt aan:

- Combat (consumables),  
- Quests (quest-items),  
- SaveSystem (inventory_state, economy_state).

### 4.8 `systems.progression`

Verantwoordelijk voor:

- XP-toekenning, level-up logica, growth curves.  
- Tri-Śarīra integratie (Body/Mind/Spirit scores en profielverschuivingen).  
- Skill-unlocks bij bepaalde levels/quests.

### 4.9 `systems.save`

Verantwoordelijk voor:

- Opbouwen van een `SaveData`-structuur (zie 3.8) op basis van alle systems.  
- Wegschrijven naar disk (JSON of gecomprimeerd bestand).  
- Laden van SaveData en systems-state herstellen.  
- Later: genereren van Trilogy Export Profiles.

---

## 5. Data-laag

### 5.1 `data.repository`

- `DataRepository` als **centrale toegang** tot JSON-data.  
- Laadt bij start alle kernbestanden of on-demand (lazy).  
- Geeft methods zoals:  
  - `get_actor(actor_id)`  
  - `get_enemies_for_group(group_id)`  
  - `get_quest(quest_id)`  
  - `get_dialogue(dialogue_id)`  
  - `get_zone(zone_id)`  
  - `get_events_for_zone(zone_id)`

### 5.2 `data.loader`

- Verantwoordelijk voor **bestands-I/O** en JSON-parsing.  
- Optioneel gekoppeld aan schema-validatiefase (build-time) i.p.v. runtime.

### 5.3 `data.validation`

- Tooling/CLI om JSON tegen schema’s te valideren en referenties te checken.  
- Wordt niet in de game zelf gebundeld, maar hoort bij de dev-toolchain.

---

## 6. Presentation & UI

### 6.1 `presentation.overworld`

- Tekent Tiled-map (layers, camera).  
- Tekent player sprite, NPC’s, objecten.  
- Leest state uit `WorldSystem` en `PartySystem` (positie, animatiestaat).

### 6.2 `presentation.battle`

- Battle UI (HP-bars, turn-indicator, skill-select).  
- Leest state uit `CombatSystem` (turn order, HP, statuses).  
- Schrijft input terug als **intents** ("use skill X op target Y").

### 6.3 `presentation.ui.common`

- Basis UI widgets (buttons, panels, textboxes).  
- Wordt gebruikt door menu’s, quest log, inventory, dialogue.

### 6.4 `presentation.ui.dialogue`

- Concreet dialoogvenster + choices.  
- Praat tegen `DialogueSystem` voor tekst & transitions.

---

## 7. Typische flows (scenario’s)

### 7.1 Spelstart → overworld

1. `Game` initialiseert alles (config, resources, data, systems).  
2. `SceneManager` activeert `MainMenuScene`.  
3. Speler kiest *New Game* → `SceneManager` schakelt naar `OverworldScene` + WorldSystem load `z_r1_chandrapur_town`.  
4. `OverworldScene` tekent map, player, NPC’s; input stuurt movement & interacties.

### 7.2 NPC-praat → queststart

1. Speler drukt interact bij elder NPC.  
2. `OverworldScene` roept `DialogueScene` / `DialogueSystem` aan met `dialogue_id`.  
3. `DialogueSystem` evalueert conditions (quest-state, flags) en geeft node/choices terug.  
4. UI toont tekst & keuzes; speler kiest *helpen*.  
5. `DialogueSystem` voert `EffectRef` uit → `QuestSystem.start_quest(q_r1_001)` + flag set.  
6. Terug naar `OverworldScene`.

### 7.3 Overworld → encounter → battle → terug

1. `WorldSystem` detecteert stappen in EncounterRegion → request battle-start met enemy-group.  
2. `SceneManager` switcht van `OverworldScene` → `BattleScene` met nieuwe `BattleContext`.  
3. `CombatSystem` runt het gevecht; bij overwinning berekent het XP, loot, quest-hooks.  
4. Resultaten worden toegepast op `PartySystem`, `ItemsSystem`, `QuestSystem`.  
5. `SceneManager` gaat terug naar `OverworldScene` op dezelfde zone/positie.

### 7.4 Save & Load

- **Save:**  
  1. Speler activeert savepunt (inn/shrine).  
  2. `SaveSystem.build_save()` trekt state op uit alle systems.  
  3. JSON wordt naar disk geschreven in betreffende slot.  
- **Load:**  
  1. In MainMenuScene kiest speler een save-slot.  
  2. `SaveSystem.load_save()` leest JSON, valideert versie.  
  3. Systems (World, Party, Quests, Time, etc.) herstellen zichzelf op basis van SaveData.  
  4. SceneManager start in `OverworldScene` op juiste zone/spawn.

---

## 8. Vertical Slice – wat moet echt bestaan?

Voor de vertical slice moeten minimaal de volgende modules **echt** geïmplementeerd zijn (ook al in simpele vorm):

- `app.game` / entrypoint met main-loop en SceneManager.  
- `core.scene`, `core.config`, `core.resources`.  
- `systems.world` (met Tiled-loader, collision, portals, chests, encounter-triggers).  
- `systems.party`, `systems.combat`, `systems.quests`, `systems.dialogue`, `systems.time`, `systems.items`, `systems.save` (light).  
- `data.repository` + JSON-loaders voor actors/enemies/items/skills/quests/dialogue/npc_schedules/events/shops/loot_tables/chests/zones.  
- `presentation.overworld`, `presentation.battle`, `presentation.ui.dialogue`, basis UI-widgets.

Andere systemen (post-game, NG+, trilogie-export) mogen al als **lege shells / placeholders** bestaan met duidelijke TODO’s.

---

## 9. Relatie met 5.3 & verdere uitwerking

- **5.3 Folder- & Module-structuur** vertaalt dit overzicht naar concrete Python-packages en paden.  
- **Scenes & State Flow – Tri-Śarīra RPG** definieert welke scenes er concreet zijn en welke state-transities bestaan; 5.2 beschrijft *hoe* dat technisch in modules en klassen landt.  
- **3.x Systems-specs** geven de inhoud per systeem; 5.2 is de glue-laag die zorgt dat ze netjes samenwerken.

Versie 0.1 is bewust *light*: genoeg richting zodat Codex/Claude een consistente structuur kan uitwerken, zonder dat alles al tot op klasse-niveau dichtgetimmerd is.

