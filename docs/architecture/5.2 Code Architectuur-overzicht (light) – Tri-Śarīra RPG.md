# 5.2 Code Architectuur-overzicht (light) – Tri-Śarīra RPG

**Versie:** 0.1  
**Auteur:** Gerald (met Architect- & Game Designer-ondersteuning)  
**Status:** Light architectuur-overzicht. Geen volledige C4-set, maar een heldere mentale map voor hoe de code in elkaar grijpt.

Doel:

- Een **overzicht in woorden** van de belangrijkste modules, lagen en afhankelijkheden.  
- Zorgen dat Codex / Claude Code begrijpt *waar* nieuwe code moet landen.  
- Aansluiten op 5.1 Tech Overview, 5.3 Folder- & Module-structuur en de 3.x/4.x systems- & dataspecs.

---

## 1. Hoofdlagen

We werken met drie hoofdlagen:

1. **App & Engine-laag**  
   - Startpunt, main-loop, Pygame-setup, SceneManager.  
   - Weinig game-logica; vooral orchestratie.

2. **Systems-laag (game logica)**  
   - World, Combat, NPC & Party, Quests & Dialogue, Time, Items/Economy, Progression & Save.  
   - Zoveel mogelijk **engine-onafhankelijk** (zuivere Python, geen Pygame in de kernlogica).

3. **Data & Content-laag**  
   - JSON-data (`data/*.json`), schema’s (`schema/*.schema.json`).  
   - Tiled-maps (`maps/*.tmx`), tilesets, assets.  
   - Worden via een `DataRepository` en maploader naar systems gevoerd.

Bovenop deze lagen zit de **UI/Presentation** (overworld rendering, menu’s, dialogueboxen, battle UI) die Pygame gebruikt om de systems-states te tonen.

---

## 2. Globale module-indeling (conceptueel)

Niet de exacte folderstructuur (die komt in 5.3), maar de **logische modules**:

- `app` – entrypoint & bootstrap  
- `core` – basisbouwstenen voor scenes, events, resources, config  
- `systems` – losse subsystemen (wereld, combat, quests, etc.)  
- `data` – runtime datalaag (loaders, repositories, schema-hooks)  
- `presentation` / `ui` – rendering & UI-componenten  
- `tools` – losse scripts (data-validatie, schema-checks, debug)

Afhankelijkheden:

- `app` → gebruikt `core`, `systems`, `data`, `presentation`.  
- `core` → is laag; moet geen concrete gamecontent kennen.  
- `systems` → mag `core` gebruiken (bijv. eventbus, base types), maar niet direct Pygame.  
- `presentation` → praat met `systems` om state op te vragen/aan te sturen.  
- `data` → wordt door `systems` gebruikt om content (actors/items/quests) te laden.

---

## 3. App & Core

### 3.1 `app.game` / `main`-entry

Belangrijkste verantwoordelijkheden:

- Pygame initialiseren (window, clock, surfaces).
- `Config` laden (paden, resolutie, dev-settings).
- `DataRepository` initialiseren (JSON-data, schema).
- Kern-systems maken via **dependency injection** (WorldSystem, CombatSystem, QuestSystem, etc.).
- `SceneStackManager` maken en initiale scene zetten (`MainMenuScene`).

De **main-loop** (in `Game.run()`):

1. Input ophalen via `SceneStackManager.handle_event()`
2. Huidige Scene updaten via `SceneStackManager.update(dt)`
3. Huidige Scene renderen via `SceneStackManager.render(surface)`
4. Display flip

`Game` implementeert `GameProtocol` zodat scenes via een abstracte interface kunnen communiceren (save/load, return to menu, start overworld).

### 3.2 `core.scene` – SceneManagerProtocol & SceneStackManager

De scene-architectuur is protocol-based:

- **`SceneManagerProtocol`** – abstracte interface voor scene managers:
  - `push_scene(scene)` – voeg scene toe bovenop stack (voor overlays/pause menu)
  - `pop_scene()` – verwijder huidige scene (terug naar vorige)
  - `switch_scene(scene)` – vervang huidige scene
  - `clear_and_set(scene)` – leeg stack en zet nieuwe scene (voor resets)
  - `handle_event()`, `update(dt)`, `render(surface)` – lifecycle methods

- **`SceneStackManager`** – concrete stack-gebaseerde implementatie:
  - Beheert een `deque[Scene]` als stack
  - Alleen de bovenste scene ontvangt input en wordt gerenderd
  - Ondersteunt overlay-scenes (pause menu over gameplay)

- **`Scene`** – abstracte basis voor concrete scenes:
  - Ontvangt `SceneManagerProtocol` via constructor
  - Abstract methods: `handle_event()`, `update()`, `render()`
  - Communiceert met game via `GameProtocol` (niet direct naar `Game` class)

Concrete scenes:

- `MainMenuScene` – start/load game menu
- `OverworldScene` – exploratie, NPC interactie, overlays (pause, shop, quest log)
- `BattleScene` – turn-based gevechten

### 3.3 `core.protocols` – Protocol-based Dependency Injection

Centraal in de architectuur staat `core/protocols.py` met **Protocols** voor alle systems:

```python
@runtime_checkable
class CombatSystemProtocol(Protocol):
    def start_battle(self, enemy_ids: list[str]) -> BattleStateView: ...
    def get_battle_state_view(self) -> BattleStateView | None: ...
    def execute_action(self, action: BattleAction) -> list[str]: ...
```

**Beschikbare Protocols:**
- `SaveableSystem` – base protocol voor save/load
- `PartySystemProtocol`, `CombatSystemProtocol`, `DialogueSystemProtocol`
- `QuestSystemProtocol`, `ShopSystemProtocol`, `EquipmentSystemProtocol`
- `InventorySystemProtocol`, `TimeSystemProtocol`, `WorldSystemProtocol`
- `FlagsSystemProtocol`, `DataRepositoryProtocol`
- `GameProtocol` – interface voor Game class (save/load, scene transitions)

**Voordelen:**
- Loose coupling: systems kennen alleen interfaces, niet concrete implementaties
- Testbaarheid: mock systems via protocols
- Type safety: `@runtime_checkable` voor isinstance checks
- Forward references: geen circulaire imports

### 3.4 `core.config` & `core.entities`

- `Config`-klasse die TOML-bestanden samenvoegt (default + dev).
- `core/entities.py` – basis dataclasses (Entity, Position).
- `core/events.py` – event definities.
- `core/game_state.py` – global game state container.

---

## 4. Systems-laag (overzicht)

### 4.1 `systems.world`

Verantwoordelijk voor:

- Laden en representeren van de **huidige zone** (Tiled-map → interne `WorldMap`).  
- Tile-collision, walkable tiles, portals, interactables, chests.  
- Positionering van **entities** (player, NPC’s, enemies op overworld).  
- Aanroepen van encounters/logica bij triggers (bv. portal betreden, EventTrigger overlappen).

Koppelt aan:

- `DataRepository` (zones, events, encounters).  
- `TiledLoader` (maps laden).  
- `TimeSystem` (dag/nacht, seizoensinvloeden op encounters).

### 4.2 `systems.combat`

Verantwoordelijk voor:

- Representatie van een **battle** (parties, turn order, acties).  
- Damage-calculatie, status effects, buffs/debuffs.  
- Verwerking van skill-effecten (`effect_ids` uit skills-data).  
- Output: battle-resultaat (XP, loot, flags zoals "boss verslagen").

Koppelt aan:

- `PartySystem` (welke actors doen mee).  
- `ItemsSystem`/Inventory (consumables in battle).  
- `QuestSystem`/Events (quest-progress na gevecht, b.v. defeat_guardian).

### 4.3 `systems.party`

Verantwoordelijk voor:

- Actieve party (volgorde, max party size).  
- Companions toevoegen/verwijderen, fasen van companions (seed/companion/settled).  
- Actor-state in memory: level, XP, stats, skills, gear (in sync met SaveData).

Koppelt aan:

- `DataRepository` (actors-data).  
- `SaveSystem` (store/restore actors-state).  
- `systems.progression` (level-ups, Tri-ontwikkeling).

### 4.4 `systems.quests`

Verantwoordelijk voor:

- Quest-log en quest-state per `quest_id`.  
- Evalueren van objectives (talk to NPC, reach zone, defeat enemy group, collect item…).  
- Hook-punten aanroepen bij events (bv. dialogue-keuze, map-enter, battle-result).

Koppelt aan:

- `systems.flags` / `systems.state` (globale flags, choice-history).  
- `DataRepository` (`quests.json`).  
- `systems.dialogue` (quest-start/advance vanuit dialogen).

### 4.5 `systems.dialogue`

Verantwoordelijk voor:

- Interpreteren van dialogue-graphs (`dialogue.json`).  
- Evalueren van conditions (flags, quest-state, tijd, companions…).  
- Teruggeven van volgende nodes, choices, text-keys.  
- Uitvoeren van effectrefs (set flag, quest-start, give item…).

Veel logica is engine-onafhankelijk; UI (dialogue-box, keuzes) zit in `presentation.ui.dialogue`.

### 4.6 `systems.time`

Verantwoordelijk voor:

- Bijhouden van **dag-index, tijd van de dag, seizoen, jaar**.  
- Triggers aanroepen op dag-/tijd-veranderingen (NPC-schedules, festival-events).  
- Mapping van tijd naar visual profiles (dag/nacht filter).

Koppelt aan:

- `npc_schedules` (waar NPC’s staan per tijdslot).  
- Encounter-tables (anders overdag vs ’s nachts).  
- Events (tijdgebonden festivals).

### 4.7 `systems.items` & `systems.economy`

Verantwoordelijk voor:

- Inventory (items, key items, quest items).  
- Toepassen van itemeffecten (healen, buffen, status herstellen).  
- Shops (beschikbare items, prijzen, stock).  
- Currencybeheer.

Koppelt aan:

- Combat (consumables),  
- Quests (quest-items),  
- SaveSystem (inventory_state, economy_state).

### 4.8 `systems.progression`

Verantwoordelijk voor:

- XP-toekenning, level-up logica, growth curves.  
- Tri-Śarīra integratie (Body/Mind/Spirit scores en profielverschuivingen).  
- Skill-unlocks bij bepaalde levels/quests.

### 4.9 `systems.save`

Verantwoordelijk voor:

- Opbouwen van een `SaveData`-structuur (zie 3.8) op basis van alle systems.  
- Wegschrijven naar disk (JSON of gecomprimeerd bestand).  
- Laden van SaveData en systems-state herstellen.  
- Later: genereren van Trilogy Export Profiles.

---

## 5. Data-laag

### 5.1 `data.repository`

- `DataRepository` als **centrale toegang** tot JSON-data.  
- Laadt bij start alle kernbestanden of on-demand (lazy).  
- Geeft methods zoals:  
  - `get_actor(actor_id)`  
  - `get_enemies_for_group(group_id)`  
  - `get_quest(quest_id)`  
  - `get_dialogue(dialogue_id)`  
  - `get_zone(zone_id)`  
  - `get_events_for_zone(zone_id)`

### 5.2 `data.loader`

- Verantwoordelijk voor **bestands-I/O** en JSON-parsing.  
- Optioneel gekoppeld aan schema-validatiefase (build-time) i.p.v. runtime.

### 5.3 `data.validation`

- Tooling/CLI om JSON tegen schema’s te valideren en referenties te checken.  
- Wordt niet in de game zelf gebundeld, maar hoort bij de dev-toolchain.

---

## 6. Presentation & UI

### 6.1 `presentation.overworld`

- Tekent Tiled-map (layers, camera).  
- Tekent player sprite, NPC’s, objecten.  
- Leest state uit `WorldSystem` en `PartySystem` (positie, animatiestaat).

### 6.2 `presentation.battle`

- Battle UI (HP-bars, turn-indicator, skill-select).  
- Leest state uit `CombatSystem` (turn order, HP, statuses).  
- Schrijft input terug als **intents** ("use skill X op target Y").

### 6.3 `presentation.ui.common`

- Basis UI widgets (buttons, panels, textboxes).  
- Wordt gebruikt door menu’s, quest log, inventory, dialogue.

### 6.4 `presentation.ui.dialogue`

- Concreet dialoogvenster + choices.
- Praat tegen `DialogueSystem` voor tekst & transitions.

### 6.5 `presentation.theme` – UI Theming

Centraal theming systeem voor consistente UI styling:

- **`Colors`** – semantische kleurnamen (BG_DARK, TEXT, HIGHLIGHT, HP, ENEMY, etc.)
- **`FontSizes`** – constanten voor typography (TINY, SMALL, NORMAL, TITLE, etc.)
- **`Spacing`** – padding/margin waarden (XS, SM, MD, LG, etc.)
- **`Sizes`** – component afmetingen (DIALOGUE_HEIGHT, SHOP_MENU, etc.)
- **`MenuColors`** / **`DialogueColors`** – frozen dataclasses met color schemes
- **`FontCache`** – cached pygame fonts (voorkomt herhaalde SysFont calls)
- **`UITheme`** – composable theme object met alle schemes
- **`ThemeProviderProtocol`** – interface voor theme injection
- **`DefaultThemeProvider`** – concrete implementatie

UI componenten ontvangen een `ThemeProviderProtocol` voor loose coupling.

---

## 6a. ViewModels – UI Data Decoupling

Systems leveren **immutable ViewModels** aan de presentation layer. Dit zorgt voor:

- **Decoupling**: UI kent geen interne system state
- **Immutability**: snapshots in tijd, geen side effects
- **Type safety**: typed dataclasses met frozen=True

### Combat ViewModels (`systems/combat_viewmodels.py`)

```python
@dataclass(frozen=True)
class CombatantView:
    actor_id: str
    name: str
    level: int
    is_enemy: bool
    is_alive: bool
    current_hp: int
    max_hp: int
    # ... resources, skills

@dataclass(frozen=True)
class BattleStateView:
    party: tuple[CombatantView, ...]
    enemies: tuple[CombatantView, ...]
    turn_order: tuple[TurnOrderEntry, ...]
    is_battle_active: bool

@dataclass(frozen=True)
class BattleAction:
    actor_id: str  # String ID, niet object reference
    action_type: ActionType
    target_id: str | None = None
    skill_id: str | None = None
```

### Dialogue ViewModels (`systems/dialogue_viewmodels.py`)

```python
@dataclass(frozen=True)
class DialogueView:
    speaker_id: str
    lines: tuple[str, ...]
    choices: tuple[ChoiceView, ...]
    can_auto_advance: bool

@dataclass(frozen=True)
class ConversationResult:
    conversation_ended: bool
    next_node_id: str | None
    effects_applied: tuple[str, ...]
```

**Flow:**
1. UI vraagt ViewModel op via SystemProtocol method
2. System bouwt immutable snapshot van state
3. UI rendert puur op basis van ViewModel
4. UI stuurt acties terug via BattleAction/choice_id (geen state mutatie)

---

## 6b. Services-laag – Data Facade

### `services/game_data.py` – GameDataService

Facade tussen presentation en data_access:

```python
class GameDataService:
    def __init__(self, data_repository: DataRepositoryProtocol): ...

    def get_item_info(self, item_id: str) -> ItemDisplayInfo | None: ...
    def get_skill_info(self, skill_id: str) -> SkillDisplayInfo | None: ...
    def get_enemy_info(self, enemy_id: str) -> EnemyDisplayInfo | None: ...
```

**View Models:**
- `ItemDisplayInfo` – item naam, type, category, stat_mods, stat_summary
- `SkillDisplayInfo` – skill naam, domain, power, cost_text
- `EnemyDisplayInfo` – enemy naam, level, type

**Voordelen:**
- UI hoeft geen raw dicts te parsen
- Typed interfaces met computed properties (e.g. `stat_summary`)
- Centraal punt voor data transformatie

---

## 7. Typische flows (scenario's)

### 7.1 Spelstart → overworld

1. `Game` initialiseert alles (config, resources, data, systems).  
2. `SceneManager` activeert `MainMenuScene`.  
3. Speler kiest *New Game* → `SceneManager` schakelt naar `OverworldScene` + WorldSystem load `z_r1_chandrapur_town`.  
4. `OverworldScene` tekent map, player, NPC’s; input stuurt movement & interacties.

### 7.2 NPC-praat → queststart

1. Speler drukt interact bij elder NPC.  
2. `OverworldScene` roept `DialogueScene` / `DialogueSystem` aan met `dialogue_id`.  
3. `DialogueSystem` evalueert conditions (quest-state, flags) en geeft node/choices terug.  
4. UI toont tekst & keuzes; speler kiest *helpen*.  
5. `DialogueSystem` voert `EffectRef` uit → `QuestSystem.start_quest(q_r1_001)` + flag set.  
6. Terug naar `OverworldScene`.

### 7.3 Overworld → encounter → battle → terug

1. `WorldSystem` detecteert stappen in EncounterRegion → request battle-start met enemy-group.  
2. `SceneManager` switcht van `OverworldScene` → `BattleScene` met nieuwe `BattleContext`.  
3. `CombatSystem` runt het gevecht; bij overwinning berekent het XP, loot, quest-hooks.  
4. Resultaten worden toegepast op `PartySystem`, `ItemsSystem`, `QuestSystem`.  
5. `SceneManager` gaat terug naar `OverworldScene` op dezelfde zone/positie.

### 7.4 Save & Load

- **Save:**  
  1. Speler activeert savepunt (inn/shrine).  
  2. `SaveSystem.build_save()` trekt state op uit alle systems.  
  3. JSON wordt naar disk geschreven in betreffende slot.  
- **Load:**  
  1. In MainMenuScene kiest speler een save-slot.  
  2. `SaveSystem.load_save()` leest JSON, valideert versie.  
  3. Systems (World, Party, Quests, Time, etc.) herstellen zichzelf op basis van SaveData.  
  4. SceneManager start in `OverworldScene` op juiste zone/spawn.

---

## 8. Vertical Slice – wat moet echt bestaan?

Voor de vertical slice moeten minimaal de volgende modules **echt** geïmplementeerd zijn (ook al in simpele vorm):

- `app.game` / entrypoint met main-loop en SceneManager.  
- `core.scene`, `core.config`, `core.resources`.  
- `systems.world` (met Tiled-loader, collision, portals, chests, encounter-triggers).  
- `systems.party`, `systems.combat`, `systems.quests`, `systems.dialogue`, `systems.time`, `systems.items`, `systems.save` (light).  
- `data.repository` + JSON-loaders voor actors/enemies/items/skills/quests/dialogue/npc_schedules/events/shops/loot_tables/chests/zones.  
- `presentation.overworld`, `presentation.battle`, `presentation.ui.dialogue`, basis UI-widgets.

Andere systemen (post-game, NG+, trilogie-export) mogen al als **lege shells / placeholders** bestaan met duidelijke TODO’s.

---

## 9. Relatie met 5.3 & verdere uitwerking

- **5.3 Folder- & Module-structuur** vertaalt dit overzicht naar concrete Python-packages en paden.  
- **Scenes & State Flow – Tri-Śarīra RPG** definieert welke scenes er concreet zijn en welke state-transities bestaan; 5.2 beschrijft *hoe* dat technisch in modules en klassen landt.  
- **3.x Systems-specs** geven de inhoud per systeem; 5.2 is de glue-laag die zorgt dat ze netjes samenwerken.

Versie 0.1 is bewust *light*: genoeg richting zodat Codex/Claude een consistente structuur kan uitwerken, zonder dat alles al tot op klasse-niveau dichtgetimmerd is.

